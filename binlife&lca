void dfs(int node, int parent, int h, vector<vector<int>> &up, vector<int> &level, vector<vector<int>> &adj, vector<int> &ht)
{
   up[node][0] = parent;
   level[node] = h;
   ht[node] = 1;
   // to move to 2^i we first move to the 2^i-1 and the i-1 steps from there
   for (int i = 1; i < K; i++)
   {
      if (up[node][i - 1] != -1)
         up[node][i] = up[up[node][i - 1]][i - 1];
      else
         up[node][i] = -1;
   }
   for (auto &i : adj[node])
   {
      if (i != parent)
      {
         dfs(i, node, h + 1, up, level, adj, ht);
         ht[node] = max(ht[i] + 1, ht[node]);
      }
   }
}
int lca(int u, int v, vector<vector<int>> &up, vector<int> &level)
{
   if (level[u] < level[v])
      swap(u, v);
   int uu = u, vv = v;
   // jumping from u node to  v to make thier level equal .... below
   for (int i = K - 1; i >= 0; i--)
   {
      if (level[u] - level[v] >= (1LL << i))
      {
         u = up[u][i];
      }
   }
   // checking if v is ancestor of u and if so return that
   if (u == v)
      return level[uu] - level[vv];
   // reaching to the closest possible node if their up values aren't equal
   for (int i = K - 1; i >= 0; i--)
   {
      if (up[u][i] != up[v][i])
      {
         u = up[u][i];
         v = up[v][i];
      }
   }
   // Lca is just one step above the node 
   int lca = up[u][0];
   // calculating the distance and returning that
   return level[uu] + level[vv] - 2 * level[lca];
}
